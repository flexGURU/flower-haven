// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users_subsriptions.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO user_subscriptions (user_id, subscription_id, start_date, end_date, day_of_week)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateUserSubscriptionParams struct {
	UserID         int64     `json:"user_id"`
	SubscriptionID int64     `json:"subscription_id"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	DayOfWeek      int16     `json:"day_of_week"`
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUserSubscription,
		arg.UserID,
		arg.SubscriptionID,
		arg.StartDate,
		arg.EndDate,
		arg.DayOfWeek,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteUserSubscription = `-- name: DeleteUserSubscription :exec
UPDATE user_subscriptions
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteUserSubscription(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserSubscription, id)
	return err
}

const getUserSubscriptionByID = `-- name: GetUserSubscriptionByID :one
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at,
    COALESCE(p1.user_json, '[]') AS user_data,
    COALESCE(p2.subscription_json, '[]') AS subscription_data,
    COALESCE(p3.payment_json, '[]') AS payment_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_agg(u.*) AS user_json
    FROM users u
    WHERE u.id = us.user_id
) p1 ON true
LEFT JOIN LATERAL (
    SELECT json_agg(s.*) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p2 ON true
LEFT JOIN LATERAL (
    SELECT json_agg(p.*) AS payment_json
    FROM payments p
    WHERE p.user_subscription_id IS NOT NULL
        AND p.user_subscription_id = $1
) p3 ON true
WHERE us.id = $2
`

type GetUserSubscriptionByIDParams struct {
	UserSubscriptionID pgtype.Int8 `json:"user_subscription_id"`
	ID                 int64       `json:"id"`
}

type GetUserSubscriptionByIDRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	UserData         []byte             `json:"user_data"`
	SubscriptionData []byte             `json:"subscription_data"`
	PaymentData      []byte             `json:"payment_data"`
}

func (q *Queries) GetUserSubscriptionByID(ctx context.Context, arg GetUserSubscriptionByIDParams) (GetUserSubscriptionByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserSubscriptionByID, arg.UserSubscriptionID, arg.ID)
	var i GetUserSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubscriptionID,
		&i.DayOfWeek,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UserData,
		&i.SubscriptionData,
		&i.PaymentData,
	)
	return i, err
}

const getUserSubscriptionsByUserID = `-- name: GetUserSubscriptionsByUserID :many
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at,
    COALESCE(p1.subscription_json, '[]') AS subscription_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_agg(json_build_object(
        'id', s.id,
        'name', s.name,
        'price', s.price 
    )) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p1 ON true
WHERE us.user_id = $1
`

type GetUserSubscriptionsByUserIDRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	SubscriptionData []byte             `json:"subscription_data"`
}

func (q *Queries) GetUserSubscriptionsByUserID(ctx context.Context, userID int64) ([]GetUserSubscriptionsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserSubscriptionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSubscriptionsByUserIDRow{}
	for rows.Next() {
		var i GetUserSubscriptionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubscriptionID,
			&i.DayOfWeek,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.SubscriptionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountUserSubscriptions = `-- name: ListCountUserSubscriptions :one
SELECT COUNT(*) AS total_user_subscriptions
WHERE
    deleted_at IS NULL
    AND (
        $1::boolean IS NULL 
        OR status = $1
    )
`

func (q *Queries) ListCountUserSubscriptions(ctx context.Context, status pgtype.Bool) (int64, error) {
	row := q.db.QueryRow(ctx, listCountUserSubscriptions, status)
	var total_user_subscriptions int64
	err := row.Scan(&total_user_subscriptions)
	return total_user_subscriptions, err
}

const listUserSubscriptions = `-- name: ListUserSubscriptions :many
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at,
    COALESCE(p1.user_json, '[]') AS user_data,
    COALESCE(p2.subscription_json, '[]') AS subscription_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_agg(json_build_object(
        'id', u.id,
        'name', u.name,
        'email', u.email,
        'phone_number', u.phone_number
    )) AS user_json
    FROM users u
    WHERE u.id = us.user_id
) p1 ON true
LEFT JOIN LATERAL (
    SELECT json_agg(json_build_object(
        'id', s.id,
        'name', s.name,
        'price', s.price 
    )) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p2 ON true
WHERE
    us.deleted_at IS NULL
    AND (
        $1::boolean IS NULL 
        OR us.status = $1
    )
ORDER BY us.created_at DESC
LIMIT $3 OFFSET $2
`

type ListUserSubscriptionsParams struct {
	Status pgtype.Bool `json:"status"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

type ListUserSubscriptionsRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	UserData         []byte             `json:"user_data"`
	SubscriptionData []byte             `json:"subscription_data"`
}

func (q *Queries) ListUserSubscriptions(ctx context.Context, arg ListUserSubscriptionsParams) ([]ListUserSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listUserSubscriptions, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSubscriptionsRow{}
	for rows.Next() {
		var i ListUserSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubscriptionID,
			&i.DayOfWeek,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UserData,
			&i.SubscriptionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserSubscription = `-- name: UpdateUserSubscription :one
UPDATE user_subscriptions
SET start_date = coalesce($1, start_date),
    end_date = coalesce($2, end_date),
    day_of_week = coalesce($3, day_of_week),
    status = coalesce($4, status)
WHERE id = $5
RETURNING id
`

type UpdateUserSubscriptionParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	DayOfWeek pgtype.Int2        `json:"day_of_week"`
	Status    pgtype.Bool        `json:"status"`
	ID        int64              `json:"id"`
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateUserSubscription,
		arg.StartDate,
		arg.EndDate,
		arg.DayOfWeek,
		arg.Status,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const userSubscriptionExists = `-- name: UserSubscriptionExists :one
SELECT EXISTS(SELECT 1 FROM user_subscriptions WHERE id = $1) AS exists
`

func (q *Queries) UserSubscriptionExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, userSubscriptionExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
