// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users_subsriptions.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const activeSubscriptions = `-- name: ActiveSubscriptions :one
SELECT COALESCE(COUNT(*), 0) AS active_subscriptions
FROM user_subscriptions
WHERE status = true
  AND deleted_at IS NULL
`

func (q *Queries) ActiveSubscriptions(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, activeSubscriptions)
	var active_subscriptions interface{}
	err := row.Scan(&active_subscriptions)
	return active_subscriptions, err
}

const createUserSubscription = `-- name: CreateUserSubscription :one
INSERT INTO user_subscriptions (user_id, subscription_id, start_date, end_date, day_of_week, frequency)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateUserSubscriptionParams struct {
	UserID         int64     `json:"user_id"`
	SubscriptionID int64     `json:"subscription_id"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	DayOfWeek      int16     `json:"day_of_week"`
	Frequency      string    `json:"frequency"`
}

func (q *Queries) CreateUserSubscription(ctx context.Context, arg CreateUserSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUserSubscription,
		arg.UserID,
		arg.SubscriptionID,
		arg.StartDate,
		arg.EndDate,
		arg.DayOfWeek,
		arg.Frequency,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteUserSubscription = `-- name: DeleteUserSubscription :exec
UPDATE user_subscriptions
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteUserSubscription(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserSubscription, id)
	return err
}

const getCountUserSubscriptionsByUserID = `-- name: GetCountUserSubscriptionsByUserID :one
SELECT COUNT(*) AS total_user_subscriptions
FROM user_subscriptions 
WHERE deleted_at IS NULL AND user_id = $1
`

func (q *Queries) GetCountUserSubscriptionsByUserID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountUserSubscriptionsByUserID, userID)
	var total_user_subscriptions int64
	err := row.Scan(&total_user_subscriptions)
	return total_user_subscriptions, err
}

const getUserSubscriptionByID = `-- name: GetUserSubscriptionByID :one
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at, us.frequency,
    COALESCE(p1.user_json, '{}') AS user_data,
    COALESCE(p2.subscription_json, '{}') AS subscription_data,
    COALESCE(p3.payment_json, '[]') AS payment_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', u.id,
        'name', u.name,
        'email', u.email,
        'phone_number', u.phone_number,
        'is_active', u.is_active,
        'is_admin', u.is_admin,
        'created_at', u.created_at
    ) AS user_json
    FROM users u
    WHERE u.id = us.user_id
) p1 ON true
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', s.id,
        'name', s.name,
        'price', s.price,
        'description', s.description,
        'product_ids', s.product_ids,
        'add_ons', s.add_ons,
        'created_at', s.created_at
    ) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p2 ON true
LEFT JOIN LATERAL (
    SELECT json_agg(p.*) AS payment_json
    FROM payments p
    WHERE p.user_subscription_id IS NOT NULL
        AND p.user_subscription_id = us.id
) p3 ON true
WHERE us.id = $1
`

type GetUserSubscriptionByIDRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	Frequency        string             `json:"frequency"`
	UserData         []byte             `json:"user_data"`
	SubscriptionData []byte             `json:"subscription_data"`
	PaymentData      []byte             `json:"payment_data"`
}

func (q *Queries) GetUserSubscriptionByID(ctx context.Context, id int64) (GetUserSubscriptionByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserSubscriptionByID, id)
	var i GetUserSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubscriptionID,
		&i.DayOfWeek,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.Frequency,
		&i.UserData,
		&i.SubscriptionData,
		&i.PaymentData,
	)
	return i, err
}

const getUserSubscriptionsByUserID = `-- name: GetUserSubscriptionsByUserID :many
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at, us.frequency,
    COALESCE(p1.subscription_json, '{}') AS subscription_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', s.id,
        'name', s.name,
        'price', s.price,
        'description', s.description,
        'product_ids', s.product_ids,
        'add_ons', s.add_ons,
        'created_at', s.created_at 
    ) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p1 ON true
WHERE us.deleted_at IS NULL AND us.user_id = $1
ORDER BY us.created_at DESC
LIMIT $3 OFFSET $2
`

type GetUserSubscriptionsByUserIDParams struct {
	UserID int64 `json:"user_id"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetUserSubscriptionsByUserIDRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	Frequency        string             `json:"frequency"`
	SubscriptionData []byte             `json:"subscription_data"`
}

func (q *Queries) GetUserSubscriptionsByUserID(ctx context.Context, arg GetUserSubscriptionsByUserIDParams) ([]GetUserSubscriptionsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserSubscriptionsByUserID, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSubscriptionsByUserIDRow{}
	for rows.Next() {
		var i GetUserSubscriptionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubscriptionID,
			&i.DayOfWeek,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.Frequency,
			&i.SubscriptionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountUserSubscriptions = `-- name: ListCountUserSubscriptions :one
SELECT COUNT(*) AS total_user_subscriptions
FROM user_subscriptions
WHERE
    deleted_at IS NULL
    AND (
        $1::boolean IS NULL 
        OR status = $1
    )
`

func (q *Queries) ListCountUserSubscriptions(ctx context.Context, status pgtype.Bool) (int64, error) {
	row := q.db.QueryRow(ctx, listCountUserSubscriptions, status)
	var total_user_subscriptions int64
	err := row.Scan(&total_user_subscriptions)
	return total_user_subscriptions, err
}

const listUserSubscriptions = `-- name: ListUserSubscriptions :many
SELECT 
    us.id, us.user_id, us.subscription_id, us.day_of_week, us.status, us.start_date, us.end_date, us.deleted_at, us.created_at, us.frequency,
    COALESCE(p1.user_json, '{}') AS user_data,
    COALESCE(p2.subscription_json, '{}') AS subscription_data
FROM user_subscriptions us
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', u.id,
        'name', u.name,
        'email', u.email,
        'phone_number', u.phone_number,
        'is_active', u.is_active,
        'is_admin', u.is_admin,
        'created_at', u.created_at
    ) AS user_json
    FROM users u
    WHERE u.id = us.user_id
) p1 ON true
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', s.id,
        'name', s.name,
        'price', s.price,
        'description', s.description,
        'product_ids', s.product_ids,
        'add_ons', s.add_ons,
        'created_at', s.created_at
    ) AS subscription_json
    FROM subscriptions s
    WHERE s.id = us.subscription_id
) p2 ON true
WHERE
    us.deleted_at IS NULL
    AND (
        $1::boolean IS NULL 
        OR us.status = $1
    )
ORDER BY us.created_at DESC
LIMIT $3 OFFSET $2
`

type ListUserSubscriptionsParams struct {
	Status pgtype.Bool `json:"status"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

type ListUserSubscriptionsRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"user_id"`
	SubscriptionID   int64              `json:"subscription_id"`
	DayOfWeek        int16              `json:"day_of_week"`
	Status           bool               `json:"status"`
	StartDate        time.Time          `json:"start_date"`
	EndDate          time.Time          `json:"end_date"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt        time.Time          `json:"created_at"`
	Frequency        string             `json:"frequency"`
	UserData         []byte             `json:"user_data"`
	SubscriptionData []byte             `json:"subscription_data"`
}

func (q *Queries) ListUserSubscriptions(ctx context.Context, arg ListUserSubscriptionsParams) ([]ListUserSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listUserSubscriptions, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSubscriptionsRow{}
	for rows.Next() {
		var i ListUserSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubscriptionID,
			&i.DayOfWeek,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.Frequency,
			&i.UserData,
			&i.SubscriptionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserSubscription = `-- name: UpdateUserSubscription :one
UPDATE user_subscriptions
SET start_date = coalesce($1, start_date),
    end_date = coalesce($2, end_date),
    day_of_week = coalesce($3, day_of_week),
    status = coalesce($4, status)
WHERE id = $5
RETURNING id
`

type UpdateUserSubscriptionParams struct {
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
	DayOfWeek pgtype.Int2        `json:"day_of_week"`
	Status    pgtype.Bool        `json:"status"`
	ID        int64              `json:"id"`
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateUserSubscription,
		arg.StartDate,
		arg.EndDate,
		arg.DayOfWeek,
		arg.Status,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const userSubscriptionExists = `-- name: UserSubscriptionExists :one
SELECT EXISTS(SELECT 1 FROM user_subscriptions WHERE id = $1) AS exists
`

func (q *Queries) UserSubscriptionExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, userSubscriptionExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
