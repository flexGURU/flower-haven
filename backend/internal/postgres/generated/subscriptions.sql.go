// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscriptions.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (name, description, product_ids, add_ons, price, stem_ids, by_admin, parent_order_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateSubscriptionParams struct {
	Name          string         `json:"name"`
	Description   string         `json:"description"`
	ProductIds    []int32        `json:"product_ids"`
	AddOns        []int32        `json:"add_ons"`
	Price         pgtype.Numeric `json:"price"`
	StemIds       []int32        `json:"stem_ids"`
	ByAdmin       bool           `json:"by_admin"`
	ParentOrderID pgtype.Int8    `json:"parent_order_id"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.Name,
		arg.Description,
		arg.ProductIds,
		arg.AddOns,
		arg.Price,
		arg.StemIds,
		arg.ByAdmin,
		arg.ParentOrderID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
UPDATE subscriptions
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubscription, id)
	return err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT 
  s.id, s.name, s.description, s.product_ids, s.add_ons, s.price, s.deleted_at, s.created_at, s.by_admin, s.stem_ids, s.parent_order_id,
  COALESCE(p1.products_json, '[]') AS products_data,
  COALESCE(p2.add_ons_json, '[]') AS add_ons_data
FROM subscriptions s
LEFT JOIN LATERAL (
  SELECT json_agg(p.*) AS products_json
  FROM products p
  WHERE p.id = ANY(s.product_ids)
) p1 ON true
LEFT JOIN LATERAL (
  SELECT json_agg(p.*) AS add_ons_json
  FROM products p
  WHERE p.id = ANY(s.add_ons)
) p2 ON true
WHERE s.id = $1
`

type GetSubscriptionByIDRow struct {
	ID            int64              `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	ProductIds    []int32            `json:"product_ids"`
	AddOns        []int32            `json:"add_ons"`
	Price         pgtype.Numeric     `json:"price"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt     time.Time          `json:"created_at"`
	ByAdmin       bool               `json:"by_admin"`
	StemIds       []int32            `json:"stem_ids"`
	ParentOrderID pgtype.Int8        `json:"parent_order_id"`
	ProductsData  []byte             `json:"products_data"`
	AddOnsData    []byte             `json:"add_ons_data"`
}

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (GetSubscriptionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i GetSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ProductIds,
		&i.AddOns,
		&i.Price,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ByAdmin,
		&i.StemIds,
		&i.ParentOrderID,
		&i.ProductsData,
		&i.AddOnsData,
	)
	return i, err
}

const listSubscriptions = `-- name: ListSubscriptions :many
SELECT 
  s.id, s.name, s.description, s.product_ids, s.add_ons, s.price, s.deleted_at, s.created_at, s.by_admin, s.stem_ids, s.parent_order_id,
  COALESCE(p.products, '[]') AS products_data,
  COALESCE(a.add_ons, '[]') AS add_ons_data
FROM subscriptions s
LEFT JOIN LATERAL (
  SELECT json_agg(json_build_object(
    'id', p.id,
    'name', p.name,
    'price', p.price
  )) AS products
  FROM products p
  WHERE p.id = ANY(s.product_ids)
) p ON true
LEFT JOIN LATERAL (
  SELECT json_agg(json_build_object(
    'id', p.id,
    'name', p.name,
    'price', p.price
  )) AS add_ons
  FROM products p
  WHERE p.id = ANY(s.add_ons)
) a ON true
WHERE 
    s.deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(s.name) LIKE $1
        OR LOWER(s.description) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR s.by_admin = $2
    )
    AND (
        $3::float IS NULL 
        OR s.price >= $3
    )
    AND (
        $4::float IS NULL 
        OR s.price <= $4
    )
ORDER BY s.created_at DESC
LIMIT $6 OFFSET $5
`

type ListSubscriptionsParams struct {
	Search    interface{}   `json:"search"`
	ByAdmin   pgtype.Bool   `json:"by_admin"`
	PriceFrom pgtype.Float8 `json:"price_from"`
	PriceTo   pgtype.Float8 `json:"price_to"`
	Offset    int32         `json:"offset"`
	Limit     int32         `json:"limit"`
}

type ListSubscriptionsRow struct {
	ID            int64              `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	ProductIds    []int32            `json:"product_ids"`
	AddOns        []int32            `json:"add_ons"`
	Price         pgtype.Numeric     `json:"price"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt     time.Time          `json:"created_at"`
	ByAdmin       bool               `json:"by_admin"`
	StemIds       []int32            `json:"stem_ids"`
	ParentOrderID pgtype.Int8        `json:"parent_order_id"`
	ProductsData  []byte             `json:"products_data"`
	AddOnsData    []byte             `json:"add_ons_data"`
}

func (q *Queries) ListSubscriptions(ctx context.Context, arg ListSubscriptionsParams) ([]ListSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptions,
		arg.Search,
		arg.ByAdmin,
		arg.PriceFrom,
		arg.PriceTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsRow{}
	for rows.Next() {
		var i ListSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ProductIds,
			&i.AddOns,
			&i.Price,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ByAdmin,
			&i.StemIds,
			&i.ParentOrderID,
			&i.ProductsData,
			&i.AddOnsData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsCount = `-- name: ListSubscriptionsCount :one
SELECT COUNT(*) AS total_subscriptions
FROM subscriptions
WHERE 
    deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(name) LIKE $1
        OR LOWER(description) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR by_admin = $2
    )
    AND (
        $3::float IS NULL 
        OR price >= $3
    )
    AND (
        $4::float IS NULL 
        OR price <= $4
    )
`

type ListSubscriptionsCountParams struct {
	Search    interface{}   `json:"search"`
	ByAdmin   pgtype.Bool   `json:"by_admin"`
	PriceFrom pgtype.Float8 `json:"price_from"`
	PriceTo   pgtype.Float8 `json:"price_to"`
}

func (q *Queries) ListSubscriptionsCount(ctx context.Context, arg ListSubscriptionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listSubscriptionsCount,
		arg.Search,
		arg.ByAdmin,
		arg.PriceFrom,
		arg.PriceTo,
	)
	var total_subscriptions int64
	err := row.Scan(&total_subscriptions)
	return total_subscriptions, err
}

const subscriptionExists = `-- name: SubscriptionExists :one
SELECT EXISTS(SELECT 1 FROM subscriptions WHERE id = $1) as exists
`

func (q *Queries) SubscriptionExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, subscriptionExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET name = coalesce($1, name),
    description = coalesce($2, description),
    product_ids = coalesce($3, product_ids),
    stem_ids = coalesce($4, stem_ids), 
    add_ons = coalesce($5, add_ons),
    price = coalesce($6, price)
WHERE id = $7
RETURNING id
`

type UpdateSubscriptionParams struct {
	Name        pgtype.Text    `json:"name"`
	Description pgtype.Text    `json:"description"`
	ProductIds  []int32        `json:"product_ids"`
	StemIds     []int32        `json:"stem_ids"`
	AddOns      []int32        `json:"add_ons"`
	Price       pgtype.Numeric `json:"price"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateSubscription,
		arg.Name,
		arg.Description,
		arg.ProductIds,
		arg.StemIds,
		arg.AddOns,
		arg.Price,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
