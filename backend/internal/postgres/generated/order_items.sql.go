// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order_items.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, amount, payment_method, frequency, stem_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateOrderItemParams struct {
	OrderID       int64          `json:"order_id"`
	ProductID     int64          `json:"product_id"`
	Quantity      int32          `json:"quantity"`
	Amount        pgtype.Numeric `json:"amount"`
	PaymentMethod string         `json:"payment_method"`
	Frequency     pgtype.Text    `json:"frequency"`
	StemID        pgtype.Int8    `json:"stem_id"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.Amount,
		arg.PaymentMethod,
		arg.Frequency,
		arg.StemID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCountOrderItemsByProductID = `-- name: GetCountOrderItemsByProductID :one
SELECT COUNT(*) AS total_order_items
FROM order_items
WHERE product_id = $1
`

func (q *Queries) GetCountOrderItemsByProductID(ctx context.Context, productID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOrderItemsByProductID, productID)
	var total_order_items int64
	err := row.Scan(&total_order_items)
	return total_order_items, err
}

const getOrderItemsByProductID = `-- name: GetOrderItemsByProductID :many
SELECT 
    oi.id, oi.order_id, oi.product_id, oi.quantity, oi.amount, oi.stem_id, oi.payment_method, oi.frequency,
    COALESCE(p1.order_json, '{}') AS order_data
FROM order_items oi
LEFT JOIN LATERAL (
    SELECT json_build_object(
        'id', o.id,
        'user_name', o.user_name,
        'user_phone_number', o.user_phone_number,
        'total_amount', o.total_amount,
        'payment_status', o.payment_status,
        'status', o.status
    ) AS order_json
    FROM orders o
    WHERE o.id = oi.order_id
) p1 ON true
WHERE oi.product_id = $1
LIMIT $3 OFFSET $2
`

type GetOrderItemsByProductIDParams struct {
	ProductID int64 `json:"product_id"`
	Offset    int32 `json:"offset"`
	Limit     int32 `json:"limit"`
}

type GetOrderItemsByProductIDRow struct {
	ID            int64          `json:"id"`
	OrderID       int64          `json:"order_id"`
	ProductID     int64          `json:"product_id"`
	Quantity      int32          `json:"quantity"`
	Amount        pgtype.Numeric `json:"amount"`
	StemID        pgtype.Int8    `json:"stem_id"`
	PaymentMethod string         `json:"payment_method"`
	Frequency     pgtype.Text    `json:"frequency"`
	OrderData     []byte         `json:"order_data"`
}

func (q *Queries) GetOrderItemsByProductID(ctx context.Context, arg GetOrderItemsByProductIDParams) ([]GetOrderItemsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByProductID, arg.ProductID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsByProductIDRow{}
	for rows.Next() {
		var i GetOrderItemsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.Amount,
			&i.StemID,
			&i.PaymentMethod,
			&i.Frequency,
			&i.OrderData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
