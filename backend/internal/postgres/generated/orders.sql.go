// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_name, user_phone_number, payment_status, status, shipping_address)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at
`

type CreateOrderParams struct {
	UserName        string      `json:"user_name"`
	UserPhoneNumber string      `json:"user_phone_number"`
	PaymentStatus   bool        `json:"payment_status"`
	Status          string      `json:"status"`
	ShippingAddress pgtype.Text `json:"shipping_address"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserName,
		arg.UserPhoneNumber,
		arg.PaymentStatus,
		arg.Status,
		arg.ShippingAddress,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :one
UPDATE orders
SET deleted_at = now()
WHERE id = $1
RETURNING id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at
`

func (q *Queries) DeleteOrder(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, deleteOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listOrder = `-- name: ListOrder :many
SELECT id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at FROM orders
WHERE
    deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(user_name) LIKE $1
        OR LOWER(user_phone_number) LIKE $1
        OR LOWER(shipping_address) LIKE $1
    )
    AND (
        COALESCE($2, '') = '' 
        OR LOWER(payment_status) LIKE $2
    )
    AND (
        COALESCE($3, '') = '' 
        OR LOWER(status) LIKE $3
    )
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListOrderParams struct {
	Search        interface{} `json:"search"`
	PaymentStatus interface{} `json:"payment_status"`
	Status        interface{} `json:"status"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

func (q *Queries) ListOrder(ctx context.Context, arg ListOrderParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrder,
		arg.Search,
		arg.PaymentStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.UserPhoneNumber,
			&i.TotalAmount,
			&i.PaymentStatus,
			&i.Status,
			&i.ShippingAddress,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const orderExists = `-- name: OrderExists :one
SELECT EXISTS(SELECT 1 FROM orders WHERE id = $1) AS exists
`

func (q *Queries) OrderExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, orderExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET user_name = coalesce($1, user_name),
    user_phone_number = coalesce($2, user_phone_number),
    payment_status = coalesce($3, payment_status),
    status = coalesce($4, status),
    shipping_address = coalesce($5, shipping_address)
WHERE id = $6
RETURNING id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at
`

type UpdateOrderParams struct {
	UserName        pgtype.Text `json:"user_name"`
	UserPhoneNumber pgtype.Text `json:"user_phone_number"`
	PaymentStatus   pgtype.Bool `json:"payment_status"`
	Status          pgtype.Text `json:"status"`
	ShippingAddress pgtype.Text `json:"shipping_address"`
	ID              int64       `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.UserName,
		arg.UserPhoneNumber,
		arg.PaymentStatus,
		arg.Status,
		arg.ShippingAddress,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}
