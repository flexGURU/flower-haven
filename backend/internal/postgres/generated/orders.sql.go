// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_name, user_phone_number, total_amount, payment_status, status, shipping_address)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateOrderParams struct {
	UserName        string         `json:"user_name"`
	UserPhoneNumber string         `json:"user_phone_number"`
	TotalAmount     pgtype.Numeric `json:"total_amount"`
	PaymentStatus   bool           `json:"payment_status"`
	Status          string         `json:"status"`
	ShippingAddress pgtype.Text    `json:"shipping_address"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserName,
		arg.UserPhoneNumber,
		arg.TotalAmount,
		arg.PaymentStatus,
		arg.Status,
		arg.ShippingAddress,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE orders
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const getOrderByFullDataID = `-- name: GetOrderByFullDataID :one
SELECT 
  o.id, o.user_name, o.user_phone_number, o.total_amount, o.payment_status, o.status, o.shipping_address, o.deleted_at, o.created_at,
  COALESCE(items.items, '[]') AS order_item_data
FROM orders o
LEFT JOIN LATERAL (
  SELECT json_agg(json_build_object(
    'id', oi.id,
    'order_id', oi.order_id,
    'product_id', oi.product_id,
    'quantity', oi.quantity,
    'amount', oi.amount,
    'current_product_details', json_build_object(
      'id', p.id,
      'name', p.name,
      'description', p.description,
      'price', p.price,
      'stock_quantity', p.stock_quantity,
      'image_url', p.image_url,
      'category_id', p.category_id,
      'created_at', p.created_at
    )
  )) AS items
  FROM order_items oi
  JOIN products p ON p.id = oi.product_id
  WHERE oi.order_id = o.id
) items ON true
WHERE o.id = $1
`

type GetOrderByFullDataIDRow struct {
	ID              int64              `json:"id"`
	UserName        string             `json:"user_name"`
	UserPhoneNumber string             `json:"user_phone_number"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	PaymentStatus   bool               `json:"payment_status"`
	Status          string             `json:"status"`
	ShippingAddress pgtype.Text        `json:"shipping_address"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt       time.Time          `json:"created_at"`
	OrderItemData   []byte             `json:"order_item_data"`
}

func (q *Queries) GetOrderByFullDataID(ctx context.Context, id int64) (GetOrderByFullDataIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByFullDataID, id)
	var i GetOrderByFullDataIDRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.OrderItemData,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.UserPhoneNumber,
		&i.TotalAmount,
		&i.PaymentStatus,
		&i.Status,
		&i.ShippingAddress,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentOrders = `-- name: GetRecentOrders :many
SELECT id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at FROM orders
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 7
`

func (q *Queries) GetRecentOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getRecentOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.UserPhoneNumber,
			&i.TotalAmount,
			&i.PaymentStatus,
			&i.Status,
			&i.ShippingAddress,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountOrder = `-- name: ListCountOrder :one
SELECT COUNT(*) AS total_orders
FROM orders
WHERE
    deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(user_name) LIKE $1
        OR LOWER(user_phone_number) LIKE $1
        OR LOWER(shipping_address) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
    AND (
        COALESCE($3, '') = '' 
        OR LOWER(status) LIKE $3
    )
`

type ListCountOrderParams struct {
	Search        interface{} `json:"search"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Status        interface{} `json:"status"`
}

func (q *Queries) ListCountOrder(ctx context.Context, arg ListCountOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, listCountOrder, arg.Search, arg.PaymentStatus, arg.Status)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const listOrder = `-- name: ListOrder :many
SELECT id, user_name, user_phone_number, total_amount, payment_status, status, shipping_address, deleted_at, created_at FROM orders
WHERE
    deleted_at IS NULL
    AND (
        COALESCE($1, '') = '' 
        OR LOWER(user_name) LIKE $1
        OR LOWER(user_phone_number) LIKE $1
        OR LOWER(shipping_address) LIKE $1
    )
    AND (
        $2::boolean IS NULL 
        OR payment_status = $2
    )
    AND (
        COALESCE($3, '') = '' 
        OR LOWER(status) LIKE $3
    )
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type ListOrderParams struct {
	Search        interface{} `json:"search"`
	PaymentStatus pgtype.Bool `json:"payment_status"`
	Status        interface{} `json:"status"`
	Offset        int32       `json:"offset"`
	Limit         int32       `json:"limit"`
}

func (q *Queries) ListOrder(ctx context.Context, arg ListOrderParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrder,
		arg.Search,
		arg.PaymentStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.UserPhoneNumber,
			&i.TotalAmount,
			&i.PaymentStatus,
			&i.Status,
			&i.ShippingAddress,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const orderExists = `-- name: OrderExists :one
SELECT EXISTS(SELECT 1 FROM orders WHERE id = $1) AS exists
`

func (q *Queries) OrderExists(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, orderExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const totalOrders = `-- name: TotalOrders :one
SELECT COUNT(*) AS total_orders
FROM orders
WHERE deleted_at IS NULL
`

func (q *Queries) TotalOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalOrders)
	var total_orders int64
	err := row.Scan(&total_orders)
	return total_orders, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET user_name = coalesce($1, user_name),
    user_phone_number = coalesce($2, user_phone_number),
    payment_status = coalesce($3, payment_status),
    status = coalesce($4, status),
    shipping_address = coalesce($5, shipping_address)
WHERE id = $6
RETURNING id
`

type UpdateOrderParams struct {
	UserName        pgtype.Text `json:"user_name"`
	UserPhoneNumber pgtype.Text `json:"user_phone_number"`
	PaymentStatus   pgtype.Bool `json:"payment_status"`
	Status          pgtype.Text `json:"status"`
	ShippingAddress pgtype.Text `json:"shipping_address"`
	ID              int64       `json:"id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.UserName,
		arg.UserPhoneNumber,
		arg.PaymentStatus,
		arg.Status,
		arg.ShippingAddress,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
