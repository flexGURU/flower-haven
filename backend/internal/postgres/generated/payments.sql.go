// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payments.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (order_id, description, user_subscription_id, amount, payment_method, paid_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, description, order_id, user_subscription_id, payment_method, amount, paid_at, created_at
`

type CreatePaymentParams struct {
	OrderID            pgtype.Int8    `json:"order_id"`
	Description        pgtype.Text    `json:"description"`
	UserSubscriptionID pgtype.Int8    `json:"user_subscription_id"`
	Amount             pgtype.Numeric `json:"amount"`
	PaymentMethod      string         `json:"payment_method"`
	PaidAt             time.Time      `json:"paid_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.OrderID,
		arg.Description,
		arg.UserSubscriptionID,
		arg.Amount,
		arg.PaymentMethod,
		arg.PaidAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.OrderID,
		&i.UserSubscriptionID,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, description, order_id, user_subscription_id, payment_method, amount, paid_at, created_at FROM payments WHERE id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.OrderID,
		&i.UserSubscriptionID,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentsByOrderID = `-- name: GetPaymentsByOrderID :one
SELECT id, description, order_id, user_subscription_id, payment_method, amount, paid_at, created_at FROM payments WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetPaymentsByOrderID(ctx context.Context, orderID pgtype.Int8) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentsByOrderID, orderID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.OrderID,
		&i.UserSubscriptionID,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentsByUserSubscriptionID = `-- name: GetPaymentsByUserSubscriptionID :one
SELECT id, description, order_id, user_subscription_id, payment_method, amount, paid_at, created_at FROM payments WHERE order_id = $1 LIMIT 1
`

func (q *Queries) GetPaymentsByUserSubscriptionID(ctx context.Context, orderID pgtype.Int8) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentsByUserSubscriptionID, orderID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.OrderID,
		&i.UserSubscriptionID,
		&i.PaymentMethod,
		&i.Amount,
		&i.PaidAt,
		&i.CreatedAt,
	)
	return i, err
}

const listCountPayments = `-- name: ListCountPayments :one
SELECT COUNT(*) AS total_payments
FROM payments
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(payment_method) LIKE $1
    )
    AND paid_at BETWEEN $2 AND $3
`

type ListCountPaymentsParams struct {
	PaymentMethod interface{}        `json:"payment_method"`
	StartDate     pgtype.Timestamptz `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) ListCountPayments(ctx context.Context, arg ListCountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, listCountPayments, arg.PaymentMethod, arg.StartDate, arg.EndDate)
	var total_payments int64
	err := row.Scan(&total_payments)
	return total_payments, err
}

const listPayments = `-- name: ListPayments :many
SELECT id, description, order_id, user_subscription_id, payment_method, amount, paid_at, created_at FROM payments
WHERE 
    (
        COALESCE($1, '') = '' 
        OR LOWER(payment_method) LIKE $1
    )
    AND paid_at BETWEEN $2 AND $3
ORDER BY paid_at DESC
LIMIT $5 OFFSET $4
`

type ListPaymentsParams struct {
	PaymentMethod interface{}        `json:"payment_method"`
	StartDate     pgtype.Timestamptz `json:"start_date"`
	EndDate       pgtype.Timestamptz `json:"end_date"`
	Offset        int32              `json:"offset"`
	Limit         int32              `json:"limit"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.PaymentMethod,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.OrderID,
			&i.UserSubscriptionID,
			&i.PaymentMethod,
			&i.Amount,
			&i.PaidAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalRevenue = `-- name: TotalRevenue :one
SELECT SUM(amount) AS total_revenue
FROM payments
`

func (q *Queries) TotalRevenue(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalRevenue)
	var total_revenue int64
	err := row.Scan(&total_revenue)
	return total_revenue, err
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET payment_method = coalesce($1, payment_method),
    amount = coalesce($2, amount),
    description = coalesce($3, description),
    paid_at = coalesce($4, paid_at)
WHERE id = $5
RETURNING id
`

type UpdatePaymentParams struct {
	PaymentMethod pgtype.Text        `json:"payment_method"`
	Amount        pgtype.Numeric     `json:"amount"`
	Description   pgtype.Text        `json:"description"`
	PaidAt        pgtype.Timestamptz `json:"paid_at"`
	ID            int64              `json:"id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (int64, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.PaymentMethod,
		arg.Amount,
		arg.Description,
		arg.PaidAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
