// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: subscription_delivery.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscriptionDelivery = `-- name: CreateSubscriptionDelivery :one
INSERT INTO subscription_deliveries (description, user_subscription_id, delivered_on)
VALUES ($1, $2, $3)
RETURNING id, description, user_subscription_id, delivered_on, deleted_at, created_at
`

type CreateSubscriptionDeliveryParams struct {
	Description        pgtype.Text `json:"description"`
	UserSubscriptionID int64       `json:"user_subscription_id"`
	DeliveredOn        time.Time   `json:"delivered_on"`
}

func (q *Queries) CreateSubscriptionDelivery(ctx context.Context, arg CreateSubscriptionDeliveryParams) (SubscriptionDelivery, error) {
	row := q.db.QueryRow(ctx, createSubscriptionDelivery, arg.Description, arg.UserSubscriptionID, arg.DeliveredOn)
	var i SubscriptionDelivery
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.UserSubscriptionID,
		&i.DeliveredOn,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSubscriptionDelivery = `-- name: DeleteSubscriptionDelivery :exec
UPDATE subscription_deliveries
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteSubscriptionDelivery(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionDelivery, id)
	return err
}

const getSubscriptionDeliveryByUserSubscriptionID = `-- name: GetSubscriptionDeliveryByUserSubscriptionID :many
SELECT id, description, user_subscription_id, delivered_on, deleted_at, created_at FROM subscription_deliveries WHERE user_subscription_id = $1
`

func (q *Queries) GetSubscriptionDeliveryByUserSubscriptionID(ctx context.Context, userSubscriptionID int64) ([]SubscriptionDelivery, error) {
	rows, err := q.db.Query(ctx, getSubscriptionDeliveryByUserSubscriptionID, userSubscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionDelivery{}
	for rows.Next() {
		var i SubscriptionDelivery
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.UserSubscriptionID,
			&i.DeliveredOn,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountSubscriptionDelivery = `-- name: ListCountSubscriptionDelivery :one
SELECT COUNT(*) AS total_subscription_deliveries 
FROM subscription_deliveries
WHERE 
    deleted_at IS NULL
`

func (q *Queries) ListCountSubscriptionDelivery(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, listCountSubscriptionDelivery)
	var total_subscription_deliveries int64
	err := row.Scan(&total_subscription_deliveries)
	return total_subscription_deliveries, err
}

const listSubscriptionDelivery = `-- name: ListSubscriptionDelivery :many
SELECT id, description, user_subscription_id, delivered_on, deleted_at, created_at FROM subscription_deliveries
WHERE 
    deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListSubscriptionDeliveryParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListSubscriptionDelivery(ctx context.Context, arg ListSubscriptionDeliveryParams) ([]SubscriptionDelivery, error) {
	rows, err := q.db.Query(ctx, listSubscriptionDelivery, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionDelivery{}
	for rows.Next() {
		var i SubscriptionDelivery
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.UserSubscriptionID,
			&i.DeliveredOn,
			&i.DeletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionDelivery = `-- name: UpdateSubscriptionDelivery :one
UPDATE subscription_deliveries
SET description = coalesce($1, description),
    delivered_on = coalesce($2, delivered_on)
WHERE id = $3
RETURNING id, description, user_subscription_id, delivered_on, deleted_at, created_at
`

type UpdateSubscriptionDeliveryParams struct {
	Description pgtype.Text        `json:"description"`
	DeliveredOn pgtype.Timestamptz `json:"delivered_on"`
	ID          int64              `json:"id"`
}

func (q *Queries) UpdateSubscriptionDelivery(ctx context.Context, arg UpdateSubscriptionDeliveryParams) (SubscriptionDelivery, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionDelivery, arg.Description, arg.DeliveredOn, arg.ID)
	var i SubscriptionDelivery
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.UserSubscriptionID,
		&i.DeliveredOn,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}
